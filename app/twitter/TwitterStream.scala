package twitter

import akka.actor.Actor
import play.api.libs.iteratee.{Iteratee, Concurrent}
import play.api.libs.json.Json
import play.api.libs.oauth.{ OAuthCalculator, ConsumerKey, RequestToken }
import play.api.libs.ws.{ WSResponseHeaders, WS }
import play.api.Play.current

object TweetStream {
	/** Indicates that the TweetStreamActor should start the WS connection to Twitter **/
	case object TweetStreamStart

	val twitterUrl = "https://stream.twitter.com/1.1/statuses/filter.json?track="
	val twitterTopics = "angularjs,playframework,elasticsearch"

	/** ConsumerKey and AccessToken for Twitter API obtained by registering an application
	  * at dev.twitter.com */
	val consumerKey = ConsumerKey(
		key = "1G8tc1opKgHW3lrEtFjhpPx3u",
		secret = "UrWLbWF6xcsu3eEjquN0usUq1xbwR7UoLWmXfjzKQWG47E3tEk"
	)

	val accessToken = RequestToken(
		token = "3433573457-sUopxt0Ayws13afTW8HE7WtTSmvb1QWnBVLOM64",
		secret = "MJZlJHmaP65ZSaeEaJGwB4eJpjPeNKfQtHBctIGciAwQy"
	)

	/** Serves as the main channel for broadcasting messages to the Play controller **/
	val (tweetStreamOut, tweetChannel) = Concurrent.broadcast[Tweet]

	/** This is the Iteratee that consumes the stream generated by the WS.get call in the TweetStreamActor **/
	def tweetIteratee(headers: WSResponseHeaders): Iteratee[Array[Byte], Unit] = {
		// We're using the default Play! executioncontext
		import play.api.libs.concurrent.Execution.Implicits.defaultContext

		if (headers.status == 200) {
			Iteratee.foreach[Array[Byte]] {
				chunk => {
					// Convert the ByteArray chunk to a UTF-8 string, then parse some JSON
					val chunkString = new String(chunk, "UTF-8")
					val jsonTweet = Json.parse(chunkString)
					println(Json.prettyPrint(jsonTweet))

					// Push the new Tweet into the channel
					tweetChannel.push(Tweet(jsonTweet))
				}
			}
		}
		else {
			// The connection somehow failed, print out what was received
			println("Something failed with the Twitter Connection ")
			Iteratee.foreach[Array[Byte]] { chunk => println(new String(chunk, "UTF-8"))}
		}
	}
}

class TweetStreamActor extends Actor {
	// We're using the default Play! executioncontext
	import play.api.libs.concurrent.Execution.Implicits.defaultContext
	import TweetStream._

	def receive = {
		case TweetStreamStart => {
			WS.url(twitterUrl + twitterTopics)
				// FIXME: This should be set to -1 once Play bug gets fixed, GitHub issue 4846
				.withRequestTimeout(Long.MaxValue)
				// Sign the Request, because Twitter requires oAuth
				.sign(OAuthCalculator(consumerKey, accessToken))
				// Get the stream, and then consume it with the tweetIteratee
				.get(TweetStream.tweetIteratee)
		}
	}
}
