package twitter

import akka.actor.{Props, ActorSystem}
import play.api.libs.iteratee.{Enumeratee, Iteratee, Concurrent}
import play.api.libs.json.{JsError, JsSuccess, JsValue, Json}
import play.api.libs.oauth.{ OAuthCalculator, ConsumerKey, RequestToken }
import play.api.libs.ws.WSResponseHeaders

import scala.util.{Failure, Success}

object TweetStream {
	val twitterUrl = "https://stream.twitter.com/1.1/statuses/filter.json?track="
	//val twitterUrl = "https://stream.twitter.com/1.1/statuses/sample.json"
	val twitterTopics = "angularjs,playframework,elasticsearch"
	//val twitterTopics = ""

	/** The TweetStream system and its actors **/
	val system = ActorSystem("TweetStream")
	val streamActor = system.actorOf(Props[TweetStreamActor], "TweetSteamer")

	/** ConsumerKey and AccessToken for Twitter API obtained by registering an application
	  * at dev.twitter.com */
	val consumerKey = ConsumerKey(
		key = "1G8tc1opKgHW3lrEtFjhpPx3u",
		secret = "UrWLbWF6xcsu3eEjquN0usUq1xbwR7UoLWmXfjzKQWG47E3tEk"
	)

	val accessToken = RequestToken(
		token = "3433573457-sUopxt0Ayws13afTW8HE7WtTSmvb1QWnBVLOM64",
		secret = "MJZlJHmaP65ZSaeEaJGwB4eJpjPeNKfQtHBctIGciAwQy"
	)

	/** Serves as the main channel for broadcasting messages to the Play controller **/
	val (tweetStreamOut, tweetChannel) = Concurrent.broadcast[Tweet]

	/** This is the Iteratee that consumes the stream generated by the WS.get call in the TweetStreamActor **/
	def tweetIteratee(headers: WSResponseHeaders): Iteratee[Array[Byte], Unit] = {
		// We're using the default Play! executioncontext
		import play.api.libs.concurrent.Execution.Implicits.defaultContext
		// Import the implicit conversion for Json -> Tweet
		import Tweet.tweetReads

		if (headers.status == 200) {
			println("Twitter request returned 200")
			// The StringBuilder servers as a buffer between the different chunks
			val buffer = new StringBuilder()
			Iteratee.foreach[Array[Byte]] {
				chunk => {
					println("Handling received chunk")
					val chunkString = new String(chunk, "UTF-8")
					buffer append chunkString
					println(chunkString)

					// This means we're at the end of the message
					if (chunkString.takeRight(2) == "\r\n" && chunkString.length > 2) {
						try {
							val jsonTweet = Json.parse(buffer.toString())
							println(Json.prettyPrint(jsonTweet))

							jsonTweet.validate[Tweet] match {
								case s: JsSuccess[Tweet] => tweetChannel.push(s.get)
								case e: JsError => println("Unable to validate JsValue as JSON Tweet")
							}

							// Clear the buffer
							buffer.clear()
						}
						catch {
							case _ => println("Something went wrong while converting the chunk")
						}
					}
				}
			}
		}
		else {
			// The connection somehow failed, print out what was received
			println("Something failed with the Twitter Connection ")
			Iteratee.foreach[Array[Byte]] { chunk => println(new String(chunk, "UTF-8"))}
		}
	}

	def tweetToJson: Enumeratee[Tweet, JsValue] = {
		// We're using the default Play! executioncontext
		import play.api.libs.concurrent.Execution.Implicits.defaultContext
		// Import the implicit conversion for Tweet -> Json
		import Tweet.tweetWrites
		Enumeratee.map[Tweet]{ Json.toJson(_) }
	}
}


